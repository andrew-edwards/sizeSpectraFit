---
title: "Summarising the analysis of Mediterranean data using MLEbins"
author: "Andrew Edwards and Juliana Zabala"
output: pdf_document
fontsize: 12pt
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  cache = FALSE,
  # cache_path = "med-summary-4-cache/",
  # fig.path = "med-summary-4-figs-cache/",
  fig.width = 8,
  fig.height = 10
)
  # comment = "#>",
```

```{r, build, echo = FALSE, eval = FALSE}
# To build either run this line or click knit button in RStudio:
rmarkdown::render("med-summary-4.Rmd")
```

```{r, packages, echo = FALSE, cache = FALSE}
library(dplyr)
load_all()
#library(sizeSpectra2)    # Need latest version
```

Copying from `mediterranean-analysis-2/zabala-summary.Rmd`, which I hadn't
updated for `mediterranean-analysis-3/`. Committing before changing anything
further.

Need to have already run `med-analysis-4.Rmd` which takes a while to run
and saves four `*_list.rds`
files in the same directory. Or just have the three files. The files contain the
results after some exploration and iterative calculations.

## Results

TODO had originally used `aggregate_mlebins()` to make tailored list, but now
just having all results then doing such wrangling here as will keep plotting code
more general (and avoids unpacking what I packed up). Can delete this comment
when done.

```{r, loadresults}
baseline_agg_list <- readRDS("baseline_agg_list.rds")
fg_agg_list <- readRDS("fg_agg_list.rds")
ntr_agg_list <- readRDS("ntr_agg_list.rds")
res_table_agg <- readRDS("res_table_agg.rds")
```

Each is a list for that strata, with 6 objects of results of class
`determine_xmin_and_fit_mlebins`. First of each is for fitting the full
community in one go, we might want to show just the curve of that fit; the
actual data will be created anyway by the amalagamating plotting.

`res_table_agg` is the summary table that has been built up during analysis (and
users should do that by using our .Rmd as a template). Was going to rebuild it
but just use what I created before for speed.

Do not really need the histogram information in each list here, and may not even
have it. So to generalise the code save strip out the histogram information if
it is exists: (could functionalise this, but a bit more transparent like this)

HERE (done) strip out the histogram stuff from each, just do a
  loop. Could make into a function. seems best to do up front allow for
  flexibility in how results were created (e.g. with hist or not), so check the class within the loop.

MWE for removing a strata, as not working with within in the function

```{r, mwe}
# I'm trying to write a function to remove certain named elements from a list

my_list <- list(a = 1, b = 2:5, c = 6)

# This works:
within(my_list,
       rm("b"))    # returns the list without b, the desired behaviour

# But cannot get it to parse correctly within a function, to make it general
remove <- function(input_list,
                   remove_me){
  within(input_list,
         # Trying various lines next, somewhat guessing

         # rm(remove_me))
            # Warning message: In rm(remove_me) : object
            # 'remove_me' not found

         # rm(expr(remove_me))          # same as above

         # rm(as.character(remove_me)))
          # Error in rm(as.character(remove_me)) (from #3) :
          #  ... must contain names or character strings
         # rm(parse(remove_me)))   # same as previous
}

remove(my_list,
       "b")

```





```{r, striphist}
remove_full <- TRUE                # whether to remove the 'full' analysis

baseline_agg_2 <- remove_hist(baseline_agg_list,
                              remove_strata = "full")
expect_equal(baseline_agg_2,
             baseline_agg)

baseline_agg_3 <- remove_hist(baseline_agg_2,
                              remove_strata = c("crust"))
baseline_agg_7 <- remove_hist(baseline_agg_list,
                              remove_strata = c("full", "crust"))

expect_equal(baseline_agg_3,
             baseline_agg_7)

then delete this if that works:   YES IT DOES HERE HERE



baseline_agg <- list()
for(i in 1:length(baseline_agg_list)){
  if("determine_xmin_and_fit_mlebins" %in% class(baseline_agg_list[[i]])){
    baseline_agg[[i]] <- baseline_agg_list[[i]]$mlebins    # might need mlebin
    # also if we have determine_xmin_and_fit_mlebin, or below TODO
  } else {
    baseline_agg[[i]] <- baseline_agg_list[[i]]    # presumably already the
                                        # mlebins or mlebin results
  }
  names(baseline_agg)[i] <- names(baseline_agg_list)[i]
}
if(remove_full){
  baseline_agg <- within(baseline_agg,
                         rm("full"))
}

fg_agg <- list()
for(i in 1:length(fg_agg_list)){
  if("determine_xmin_and_fit_mlebins" %in% class(fg_agg_list[[i]])){
    fg_agg[[i]] <- fg_agg_list[[i]]$mlebins    # might need mlebin
    # also if we have determine_xmin_and_fit_mlebin, or below TODO
  } else {
    fg_agg[[i]] <- fg_agg_list[[i]]    # presumably already the
                                        # mlebins or mlebin results
  }
  names(fg_agg)[i] <- names(fg_agg_list)[i]
}
if(remove_full){
  fg_agg <- within(fg_agg,
                   rm("full"))
}


ntr_agg <- list()
for(i in 1:length(ntr_agg_list)){
  if("determine_xmin_and_fit_mlebins" %in% class(ntr_agg_list[[i]])){
    ntr_agg[[i]] <- ntr_agg_list[[i]]$mlebins    # might need mlebin
    # also if we have determine_xmin_and_fit_mlebin, or below TODO
  } else {
    ntr_agg[[i]] <- ntr_agg_list[[i]]    # presumably already the
                                        # mlebins or mlebin results
  }
  names(ntr_agg)[i] <- names(ntr_agg_list)[i]
}
if(remove_full){
  ntr_agg <- within(ntr_agg,
                    rm("full"))
}

```

\clearpage

```{r, aggregatetable}
knitr::kable(res_table_agg,
             digits = 2)
```

First, need a global range for the body sizes, note those include full community
that we might not look at, so may always want to come back and tweak
```{r, globalx}
x_min_global <- min(res_table_agg$x_min)
x_max_global <- max(res_table_agg$x_max)
groups <- unique(res_table_agg$Group)    # Assume we're keeping everything in
                                         # the same order, no reason not to
groups <- groups[groups != "Full community"]  # Since don't want plots for full
                                        # community for this particular analysis
```

TODO Need to summarise those results in a plot of $b$ with confidence
intervals.

## Figures -- one figure with 12 panels

Could also plot each one in turn with linear y-axis also will probably want in
an Appendix. Do panel plot first.

```{r, panelplot, fig.cap = "Summary plot of all groups (rows) and strata(columns), with a consistent x-axis range throughout, and a consistent y-axis range for each group. Data are shown as rectangles representing the range of possible values within each body-mass bin, but due to the small bins these mostly show up as lines."}
par(mfrow = c(5, 3),    # group in each row, strata in each column
    oma = c(0, 3, 3, 0),
    mar = c(3, 3, 1, 0.2))

seg_col = "black"      # bins are so small the default green does not really
                       # help

for(i in 1:length(groups)){
  # Based on calculation in plot.size_spectrum_mlebin():
  y_min_group <- 0.75 * min(c(baseline_agg[[i]]$data$count_gte_bin_min,
                              fg_agg[[i]]$data$count_gte_bin_min,
                              ntr_agg[[i]]$data$count_gte_bin_min))

  y_max_group <- max(c(baseline_agg[[i]]$data$high_count,
                       fg_agg[[i]]$data$high_count,
                       ntr_agg[[i]]$data$high_count))

  y_lim_group = c(y_min_group,
                  y_max_group)

  plot(baseline_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 4,
       seg_col = seg_col,
       show_fit_on_top = FALSE)

  mtext(groups[i],
        side = 2,
        line = 3)

  if(i == 1){
    mtext("Baseline",
          side = 3,
          line = 1)
  }

  plot(fg_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 4,
       seg_col = seg_col,
       ylab = "",
       show_fit_on_top = FALSE)

  if(i == 1){
    mtext("Fishing Grounds",
          side = 3,
          line = 1)
  }

  plot(ntr_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 4,
       seg_col = seg_col,
       ylab = "",
       show_fit_on_top = FALSE)

  if(i == 1){
    mtext("No-take Reserve",
          side = 3,
          line = 1)
  }
}
```

## Conclusions from these results

TODO not updated this text yet, doing figures first

From theory we would expect a steepening of the size spectrum ($b$ becoming more
negative) under fishing
pressure, because larger organisms get fished out, releasing some predation pressure on
smaller organisms. For a No-take Reserve we would conversely expect a shallowing
of the size spectrum ($b$ become less negative).

Presumably the baseline ecosystem was already experiencing fishing pressure, so
the ideal theoretical results would be the FG staying the same as the baseline
(or maybe shallowing as the area is adjacent to the NTR), and the NTR shallowing.

The table and figure show the following:

Crustacea: From the baseline, FG steepens quite a bit and NTR less so. So NTR
indeed shallower than FG, but it did steepen a little from baseline.

Actinopterygii: From the baseline, FG steepened and NTR got shallower.

Chondrichthyes: From the baseline, FG got shallower, and NTR got even
shallower.

Cephalopoda small: Cephalopoda were tricky to fit, in terms of specifying xmin
and xmax. Strangely, from the baseline the FG got shallower (by quite a bit) and the NTR
steepened, opposite to what we would theoretically expect.

Cephalopoda large: From the baseline, the FG shallowed slightly, while NTR
steepened.

So the first three groups all find the resulting NTR to have a shallower size
spectrum than for the FG, in agreement with the ideal theoretically expected
directions. For both Cephalopoda, the results were opposite to what was
expected, but the data had to be divided into small and large, which could maybe
be done differently.

## Aggregating onto one plot

TODO This is still rough, but the idea (and it won't be clear what is what), but
the idea is to do the same kind of aggregated plot for baseline, FG, and NTR,
and then maybe plot the aggregated fit from each on the same panel, which will
hopefully show the effect of the NTR.

HERE sort of works, needs tweaking but getting there
Aiming for:
```{r aggplot, fig.height = 10}
xlim_global <- c(0.3, 2000)   # TODO automate
ylim_global <- c(1, 200000)
par(mfrow = c(3, 1))
baseline_agg_fit <- plot_aggregate_mlebin(
  baseline_agg,
  main = "Baseline",   # Didn't get used TODO
  xlim_global = xlim_global,
  ylim_global = ylim_global)
fg_agg_fit <- plot_aggregate_mlebin(
  fg_agg,
  main = "Fishing Grounds",
  xlim_global = xlim_global,
  ylim_global = ylim_global)
ntr_agg_fit <- plot_aggregate_mlebin(
  ntr_agg,
  main = "No-take Reserve",
  xlim_global = xlim_global,
  ylim_global = ylim_global)
```


Try and plot all three fits on one plot:
```{r combinedplot}
strata_col <- c("black",
                "blue",
                "red")

plot(baseline_agg_fit[["x_plb_agg"]],
     baseline_agg_fit[["y_plb_agg"]],
     log = "xy",
     type = "l",
     xlim = xlim_global,
     ylim = ylim_global,
     col = strata_col[1],
     main = "Base black, fg blue, ntr red")

lines(fg_agg_fit[["x_plb_agg"]],
      fg_agg_fit[["y_plb_agg"]],
      col = strata_col[2])

lines(ntr_agg_fit[["x_plb_agg"]],
      ntr_agg_fit[["y_plb_agg"]],
      col = strata_col[3])
```

Do not log the y-axis:
```{r combinedplotnolog}
plot(baseline_agg_fit[["x_plb_agg"]],
     baseline_agg_fit[["y_plb_agg"]],
     log = "x",
     type = "l",
     xlim = xlim_global,
     ylim = ylim_global,
     col = strata_col[1],
     main = "Base black, fg blue, ntr red")

lines(fg_agg_fit[["x_plb_agg"]],
      fg_agg_fit[["y_plb_agg"]],
      col = strata_col[2])

lines(ntr_agg_fit[["x_plb_agg"]],
      ntr_agg_fit[["y_plb_agg"]],
      col = strata_col[3])
```



Now normalise the y-axis:
```{r combinedplotnorm}
plot(baseline_agg_fit[["x_plb_agg"]],
     baseline_agg_fit[["y_plb_agg"]] / max(baseline_agg_fit[["y_plb_agg"]]),
     log = "xy",
     type = "l",
     xlim = xlim_global,
     ylim = c(0.001, 1),
     col = strata_col[1],
     main = "Base black, fg blue, ntr red",
     lwd = 2)

lines(fg_agg_fit[["x_plb_agg"]],
      fg_agg_fit[["y_plb_agg"]] / max(fg_agg_fit[["y_plb_agg"]]),
      col = strata_col[2],
     lwd = 2)

lines(ntr_agg_fit[["x_plb_agg"]],
      ntr_agg_fit[["y_plb_agg"]] / max(ntr_agg_fit[["y_plb_agg"]]),
      col = strata_col[3],
      lwd = 2)
```

Might look better if xmin are consistent?
