---
title: "Summarising the analysis of Mediterranean data using MLEbins"
author: "Andrew Edwards and Juliana Zabala"
output: pdf_document
fontsize: 12pt
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
header-includes:
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  cache = TRUE,
  cache_path = "med-summary-4-cache/",
  fig.path = "med-summary-4-figs-cache/",
  fig.width = 8,
  fig.height = 10
)
# comment = "#>",

knitr::dep_auto()
```

```{r, build, echo = FALSE, eval = FALSE}
# To build either run this line or click knit button in RStudio:
rmarkdown::render("med-summary-4.Rmd")
```

```{r, packages, echo = FALSE, cache = FALSE}
library(dplyr)
library(knitr)
load_all()
#library(sizeSpectra2)    # Need latest version
```

This summarises the results from `med-analysis-4.Rmd`, which takes a while to run
and saves three `*_list.rds`
files in the same directory. The files contain the
results after some exploration and iterative calculations, plus
`res_table_agg.rds` contains the combined table results. Still might need some
of the other plots in `med-analysis-*.Rmd` in Supplementary Information.

## Load results

Load in saved results.

```{r, loadresults}
baseline_agg_list <- readRDS("baseline_agg_list.rds")
fg_agg_list <- readRDS("fg_agg_list.rds")
ntr_agg_list <- readRDS("ntr_agg_list.rds")
res_table_agg <- readRDS("res_table_agg.rds")
```

Each is a list for that strata, with 6 objects of results of class
`determine_xmin_and_fit_mlebins`. First of each is for fitting the full
community in one go, which we won't use as not a great fit and there are issues
with assuming the same catchability (TODO?) between groups. Fits for all
group/strata combination (including the full community) are shown at the end of
this document.

`res_table_agg` is the summary table that has been built up during analysis (and
users should do that by using our .Rmd as a template).


## Fits to each species group

Do not really need the histogram information in each list here, so stripping out
the histogram information here, and also removing the `"full"` analyses as do
not want to include them:

```{r, striphist}
remove_strata <- "full"   # make NULL to keep everything, or "full" to remove
                          # the full analysis

baseline_agg <- remove_hist(baseline_agg_list,
                            remove_strata = remove_strata)

fg_agg <- remove_hist(fg_agg_list,
                      remove_strata = remove_strata)

ntr_agg <- remove_hist(ntr_agg_list,
                       remove_strata = remove_strata)
```

\clearpage

```{r, aggregatetable}
knitr::kable(dplyr::filter(res_table_agg,
                           Group != "Full community"),
             digits = 2)
```

First, need a global range for the body sizes, note those include full community
that we might not look at, so may always want to come back and tweak:
```{r, globalx}
x_min_global <- min(res_table_agg$x_min)
x_max_global <- max(res_table_agg$x_max)
groups <- unique(res_table_agg$Group)    # Assume we're keeping everything in
                                         # the same order, no reason not to
groups <- groups[groups != "Full community"]  # Since don't want plots for full
                                        # community for this particular
                                        # analysis. Edit manually if want to
                                        # ignore more.
strata <- unique(dplyr::filter(res_table_agg,
                               Group != "Full community")$Strata)
```

## Figures -- one figure with 12 panels

Could also plot each one in turn with linear y-axis also will probably want in
an Appendix. Do panel plot first. Two sets of code, first for portrait version,
second (not echoed) original code for landscape to have it available; bit hard
to functionalise as usually want to tailor the plots.

```{r, panelplotportrait, fig.cap = "Summary plot of all groups (rows) and strata(columns), with a consistent x-axis range throughout, and a consistent y-axis range for each group. Data are shown as rectangles representing the range of possible values within each body-mass bin, but due to the small bins these mostly show up as lines.", echo = FALSE, eval = FALSE}
# NOT EVALUATED
par(mfrow = c(5, 3),    # group in each row, strata in each column
    oma = c(0, 3, 3, 0),
    mar = c(3, 3, 1, 0.2))

seg_col = "black"      # bins are so small the default green does not really
                       # help

for(i in 1:length(groups)){
  # Based on calculation in plot.size_spectrum_mlebin():
  y_min_group <- 0.75 * min(c(baseline_agg[[i]]$data$count_gte_bin_min,
                              fg_agg[[i]]$data$count_gte_bin_min,
                              ntr_agg[[i]]$data$count_gte_bin_min))

  y_max_group <- max(c(baseline_agg[[i]]$data$high_count,
                       fg_agg[[i]]$data$high_count,
                       ntr_agg[[i]]$data$high_count))

  y_lim_group = c(y_min_group,
                  y_max_group)

  plot(baseline_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 4,
       seg_col = seg_col,
       show_fit_on_top = FALSE)

  mtext(groups[i],
        side = 2,
        line = 3)

  if(i == 1){
    mtext("Baseline",
          side = 3,
          line = 1)
  }

  plot(fg_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 4,
       seg_col = seg_col,
       ylab = "",
       show_fit_on_top = FALSE)

  if(i == 1){
    mtext("Fishing Grounds",
          side = 3,
          line = 1)
  }

  plot(ntr_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 4,
       seg_col = seg_col,
       ylab = "",
       show_fit_on_top = FALSE)

  if(i == 1){
    mtext("No-take Reserve",
          side = 3,
          line = 1)
  }
}
```

\blandscape

```{r, panelplotlandscape, fig.cap = "Summary plot of all groups (rows) and strata(columns), with a consistent x-axis range throughout, and a consistent y-axis range for each group. Data are shown as rectangles representing the range of possible values within each body-mass bin, but due to the small bins these mostly show up as lines. Solid curves are the fits using the maximum likelihood estimates for exponent $b$, dashed lines use the 95% confidence intervals, but these only show up in a few cases.", echo = FALSE, fig.width = 11, fig.height = 8}
strata_col = c("blue",
               "darkgreen",
               "red")  # used in later figures also

par(mfcol = c(3, 5),    # strata in each row, group in each colum, fill by group
    oma = c(0, 3, 3, 0),
    mar = c(3, 3, 1, 0.2))

seg_col = "black"      # bins are so small the default green does not really
                       # help

for(i in 1:length(groups)){
  # Based on calculation in plot.size_spectrum_mlebin():
  y_min_group <- 0.75 * min(c(baseline_agg[[i]]$data$count_gte_bin_min,
                              fg_agg[[i]]$data$count_gte_bin_min,
                              ntr_agg[[i]]$data$count_gte_bin_min))

  y_max_group <- max(c(baseline_agg[[i]]$data$high_count,
                       fg_agg[[i]]$data$high_count,
                       ntr_agg[[i]]$data$high_count))

  y_lim_group = c(y_min_group,
                  y_max_group)

  # Only label y-axis for first column
  y_lab <- ifelse(i == 1,
                  expression(paste("Total ",
                                   counts >= x),
                             sep=""),
                  "")

  plot(baseline_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 3,
       seg_col = seg_col,
       xlab = "",
       ylab = y_lab,
       fit_col = strata_col[1],
       show_fit_on_top = FALSE)

  mtext(groups[i],
        side = 3,
        line = 1)

  if(i == 1){
    mtext("Baseline",
          side = 2,
          line = 3)
  }

  plot(fg_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 3,
       seg_col = seg_col,
       xlab = "",
       ylab = y_lab,
       fit_col = strata_col[2],
       show_fit_on_top = FALSE)

  if(i == 1){
    mtext("Fishing Grounds",
          side = 2,
          line = 3)
  }

  plot(ntr_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "log_y_axis",
       legend_text_second_row_multiplier = 3,
       seg_col = seg_col,
       ylab = y_lab,
       fit_col = strata_col[3],
       show_fit_on_top = FALSE)

  if(i == 1){
    mtext("No-take Reserve",
          side = 2,
          line = 3)
  }
}
```

\elandscape


\blandscape

```{r, panelplotlandscapelinear, fig.cap = "As for previous figure but with linear y-axes.", echo = FALSE, fig.width = 11, fig.height = 8}
par(mfcol = c(3, 5),    # strata in each row, group in each colum, fill by group
    oma = c(0, 3, 3, 0),
    mar = c(3, 3, 1, 0.2))

seg_col = "black"      # bins are so small the default green does not really
                       # help

for(i in 1:length(groups)){
  # Based on calculation in plot.size_spectrum_mlebin():
  y_min_group <- 0.75 * min(c(baseline_agg[[i]]$data$count_gte_bin_min,
                              fg_agg[[i]]$data$count_gte_bin_min,
                              ntr_agg[[i]]$data$count_gte_bin_min))

  y_max_group <- max(c(baseline_agg[[i]]$data$high_count,
                       fg_agg[[i]]$data$high_count,
                       ntr_agg[[i]]$data$high_count))

  y_lim_group = c(y_min_group,
                  y_max_group)

  # Only label y-axis for first column
  y_lab <- ifelse(i == 1,
                  expression(paste("Total ",
                                   counts >= x),
                             sep=""),
                  "")

  plot(baseline_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "linear_y_axis",
       legend_text_second_row_multiplier = 3,
       seg_col = seg_col,
       xlab = "",
       ylab = y_lab,
       fit_col = strata_col[1],
       show_fit_on_top = FALSE)

  mtext(groups[i],
        side = 3,
        line = 1)

  if(i == 1){
    mtext("Baseline",
          side = 2,
          line = 3)
  }

  plot(fg_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "linear_y_axis",
       legend_text_second_row_multiplier = 3,
       seg_col = seg_col,
       xlab = "",
       ylab = y_lab,
       fit_col = strata_col[2],
       show_fit_on_top = FALSE)

  if(i == 1){
    mtext("Fishing Grounds",
          side = 2,
          line = 3)
  }

  plot(ntr_agg[[i]],
       xlim = c(x_min_global,
                x_max_global),
       ylim = y_lim_group,
       style = "linear_y_axis",
       legend_text_second_row_multiplier = 3,
       seg_col = seg_col,
       ylab = y_lab,
       fit_col = strata_col[3],
       show_fit_on_top = FALSE)

  if(i == 1){
    mtext("No-take Reserve",
          side = 2,
          line = 3)
  }
}
```

\elandscape



## Summarise exponent values

```{r plotsummary, fig.width = 10.2, fig.height = 6, fig.cap = "Maximum likelihood estimates of size-spectrum exponent $b$ (symbols) with 95% confidence intervals (lines), most of which are too narrow to show up. Results are for Baseline, Fishing Grounds (FG) and No-take Reserve (NTR) for each species group."}
plot_multiple_exponents(res_table_agg,
                        col_strata = strata_col)
```

The low value does dictate the y-axis range, so limit the axis here:
```{r plotsummary2, fig.width = 11, fig.height = 6, fig.cap = "As for previous Figure but restricting the y-axis (which misses the NTR results for Chondrichthyes)."}
plot_multiple_exponents(res_table_agg,
                        ylim = c(-5, 0),
                        col_strata = strata_col)
```

\clearpage

## Conclusions from these results

TODO not updated this text yet, doing figures first

From theory we would expect a steepening of the size spectrum ($b$ becoming more
negative) under fishing
pressure, because larger organisms get fished out, releasing some predation pressure on
smaller organisms. For a No-take Reserve we would conversely expect a shallowing
of the size spectrum ($b$ become less negative).

Presumably the baseline ecosystem was already experiencing fishing pressure, so
the ideal theoretical results would be the FG staying the same as the baseline
(or maybe shallowing as the area is adjacent to the NTR), and the NTR shallowing.

The table and figure show the following:

Crustacea: From the baseline, FG steepens quite a bit and NTR less so. So NTR
indeed shallower than FG, but it did steepen a little from baseline.

Actinopterygii: From the baseline, FG steepened and NTR got shallower.

Chondrichthyes: From the baseline, FG got shallower, and NTR got even
shallower.

Cephalopoda small: Cephalopoda were tricky to fit, in terms of specifying xmin
and xmax. Strangely, from the baseline the FG got shallower (by quite a bit) and the NTR
steepened, opposite to what we would theoretically expect.

Cephalopoda large: From the baseline, the FG shallowed slightly, while NTR
steepened.

So the first three groups all find the resulting NTR to have a shallower size
spectrum than for the FG, in agreement with the ideal theoretically expected
directions. For both Cephalopoda, the results were opposite to what was
expected, but the data had to be divided into small and large, which could maybe
be done differently.

## Aggregating onto one plot

```{r aggplot, fig.height = 8, fig.width = 4, fig.cap = "For each strata, the data and fits previously shown for the five species groups are plotted on the same axes. The thick pink lines are then aggregated size spectra, which combine the five fitted size spectra (all the data are also shown in black, though this is hard to see). While the results are a little hard to interpret, the point is to show how the three aggregated pink curves are defined, and these are then compared in the next figure."}
xlim_global <- c(x_min_global,
                 x_max_global)
ylim_global <- c(1, 200000)
par(mfrow = c(3, 1),
    oma = c(0, 3, 3, 0),
    mar = c(4, 3, 1, 0.2))

baseline_agg_fit <- plot_aggregate_mlebin(
  baseline_agg,
  xlim_global = xlim_global,
  ylim_global = ylim_global)
mtext("Baseline",
      side = 3,
      line = 0.5)

fg_agg_fit <- plot_aggregate_mlebin(
  fg_agg,
  # main = "Fishing Grounds",
  xlim_global = xlim_global,
  ylim_global = ylim_global)
mtext("Fishing Grounds",
      side = 3,
      line = 0.5)

ntr_agg_fit <- plot_aggregate_mlebin(
  ntr_agg,
  # main = "No-take Reserve",
  xlim_global = xlim_global,
  ylim_global = ylim_global)
mtext("No-take Reserve",
      side = 3,
      line = 0.5)
```


Try and plot all three fits on one plot:
```{r combinedplot, fig.cap = "The three aggregated plots from the previous Figure.", fig.height = 6}
plot(baseline_agg_fit[["x_plb_agg"]],
     baseline_agg_fit[["y_plb_agg"]],
     log = "xy",
     type = "l",
     xlim = xlim_global,
     ylim = ylim_global,
     xlab = expression(paste("Body mass, ",
                             italic(x), "(g)")),
     ylab = expression(paste("Total ", counts >= x),
                       sep=""),
     col = strata_col[1],
     axes = FALSE,
     lwd = 2)

box()

add_ticks(log = "xy")

lines(fg_agg_fit[["x_plb_agg"]],
      fg_agg_fit[["y_plb_agg"]],
      col = strata_col[2],
      lwd = 2)

lines(ntr_agg_fit[["x_plb_agg"]],
      ntr_agg_fit[["y_plb_agg"]],
      col = strata_col[3],
      lwd = 2)

legend(x = "topright",
       legend = strata,
       col = strata_col,
       lwd = 2)
       # pch = pch_strata,
       # pt.cex = pch_cex,
       # inset = legend_inset,
       # bty = legend_bty)
```

Do not log the y-axis:  TODO could make function
```{r combinedplotnolog, fig.cap = "As for previous figure but linear y-axis.", fig.height = 6}
plot(baseline_agg_fit[["x_plb_agg"]],
     baseline_agg_fit[["y_plb_agg"]],
     log = "x",
     type = "l",
     xlim = xlim_global,
     ylim = ylim_global,
     xlab = expression(paste("Body mass, ",
                             italic(x), "(g)")),
     ylab = expression(paste("Total ", counts >= x),
                       sep=""),
     col = strata_col[1],
     axes = FALSE,
     lwd = 2)

box()

add_ticks(log = "x")

lines(fg_agg_fit[["x_plb_agg"]],
      fg_agg_fit[["y_plb_agg"]],
      col = strata_col[2],
      lwd = 2)

lines(ntr_agg_fit[["x_plb_agg"]],
      ntr_agg_fit[["y_plb_agg"]],
      col = strata_col[3],
      lwd = 2)

legend(x = "topright",
       legend = strata,
       col = strata_col,
       lwd = 2)
```

Restrict the curves to the max of the xmin, then normalise:
```{r combinedplotnorm, fig.cap = "The three aggregated plots restricted to a common range of body masses and then normalised, to properly compare them.", fig.height = 6}
x_restrict_start <- max(c(min(baseline_agg_fit[["x_plb_agg"]]),
                          min(fg_agg_fit[["x_plb_agg"]]),
                          min(ntr_agg_fit[["x_plb_agg"]])))

baseline_agg_fit_x <- baseline_agg_fit[["x_plb_agg"]][baseline_agg_fit[["x_plb_agg"]] >=
                                                      x_restrict_start]
baseline_agg_fit_y <- baseline_agg_fit[["y_plb_agg"]][baseline_agg_fit[["x_plb_agg"]] >=
                                                      x_restrict_start]
baseline_agg_fit_y_norm <- baseline_agg_fit_y / max(baseline_agg_fit_y)

plot(baseline_agg_fit_x,
     baseline_agg_fit_y_norm,
     log = "xy",
     type = "l",
     xlim = c(1, xlim_global[2]),
     ylim = c(10^(-4), 1),
     xlab = expression(paste("Body mass, ",
                             italic(x), "(g)")),
     ylab = expression(paste("Proportion of ", counts >= x),
                       sep=""),
     col = strata_col[1],
     axes = FALSE,
     lwd = 2)

box()

add_ticks(log = "xy")

fg_agg_fit_x <- fg_agg_fit[["x_plb_agg"]][fg_agg_fit[["x_plb_agg"]] >=
                                                      x_restrict_start]
fg_agg_fit_y <- fg_agg_fit[["y_plb_agg"]][fg_agg_fit[["x_plb_agg"]] >=
                                                      x_restrict_start]
fg_agg_fit_y_norm <- fg_agg_fit_y / max(fg_agg_fit_y)


lines(fg_agg_fit_x,
      fg_agg_fit_y_norm,
      col = strata_col[2],
      lwd = 2)

ntr_agg_fit_x <- ntr_agg_fit[["x_plb_agg"]][ntr_agg_fit[["x_plb_agg"]] >=
                                                      x_restrict_start]
ntr_agg_fit_y <- ntr_agg_fit[["y_plb_agg"]][ntr_agg_fit[["x_plb_agg"]] >=
                                                      x_restrict_start]
ntr_agg_fit_y_norm <- ntr_agg_fit_y / max(ntr_agg_fit_y)


lines(ntr_agg_fit_x,
      ntr_agg_fit_y_norm,
      col = strata_col[3],
      lwd = 2)

legend(x = "topright",
       legend = strata,
       col = strata_col,
       lwd = 2)
       # pch = pch_strata,
       # pt.cex = pch_cex,
       # inset = legend_inset,
       # bty = legend_bty)
```

```{r combinedplotnormlinear, fig.cap = "As previous figure but with a linear y-axis.",fig.height = 6}
plot(baseline_agg_fit_x,
     baseline_agg_fit_y_norm,
     log = "x",
     type = "l",
     xlim = c(1, xlim_global[2]),
     ylim = c(10^(-4), 1),
     xlab = expression(paste("Body mass, ",
                             italic(x), "(g)")),
     ylab = expression(paste("Proportion of ", counts >= x),
                       sep=""),
     col = strata_col[1],
     axes = FALSE,
     lwd = 2)

box()

add_ticks(log = "x",
          y_big_ticks_labels = seq(0, 1, 0.2),
          y_small_ticks_by = 0.1)

lines(fg_agg_fit_x,
      fg_agg_fit_y_norm,
      col = strata_col[2],
      lwd = 2)

lines(ntr_agg_fit_x,
      ntr_agg_fit_y_norm,
      col = strata_col[3],
      lwd = 2)

legend(x = "topright",
       legend = strata,
       col = strata_col,
       lwd = 2)
       # pch = pch_strata,
       # pt.cex = pch_cex,
       # inset = legend_inset,
       # bty = legend_bty)
```

TODO totally make a function I think, since ended up calling several times, but
was useful to tweak.


## Fits to each group/strata combination in turn

Might just want to show the figures here, basically copying just the plotting
code from `med-analysis-*.Rmd`.

```{r, stop, cache = FALSE}
knitr::knit_exit()
```


## Failed attempts as referencing figures

Fig. \@ref(fig:cars)

Fig. \\@ref(fig:cars)

(ref:first-fig-caption) Here's a complicated figure caption for the first figure, which can include complicated text styling like $m^2$ and references to other elements in the document, like Fig. \@ref(fig:cars).

```{r pressure, fig.cap = '(ref:first-fig-caption)'}
plot(1:10)
```

(ref:second-fig-caption) Here's a second complicated figure caption.

```{r, cars, fig.cap = '(ref:second-fig-caption)'}
plot(10:200)
```
