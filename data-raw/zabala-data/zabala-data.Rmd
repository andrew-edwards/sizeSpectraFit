---
title: "Putting Juliana Zabala's datainto sizeSpectra2"
author: "Andrew Edwards and Juliana Zabala"
output: pdf_document
fontsize: 12pt
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  cache = FALSE,
  # cache_path = "zabala-data-cache/",
  # fig.path = "zabala-data-figs-cache/",
  fig.width = 7,
  fig.height = 6
)
  # comment = "#>",
```

```{r, build, echo = FALSE, eval = FALSE}
# To build either run this line or click knit button in RStudio:
rmarkdown::render("zabala-data.Rmd")
```

```{r, packages, echo = FALSE}
library(dplyr)
load_all()
#library(sizeSpectra2)    # Need latest version
# LIBRARIES ####
# Andy commenting some of these that I think aren't needed here (I didn't have
# some installed and the code still ran):
# library(tidyverse)      # not sure all these are needed
library(readxl)
# library(plyr)           # gives a warning of conflicts with dplyr
# library(caret)
# library(vegan)
# library(ggvegan)  # Juliana had this commented out already
# library(forams)
#library(tibble)
# library(ggplot2)
```

```{r, notes, echo = FALSE}
# Notes from R file:

# Adapting this from using-sizeSpectra2.R in size-spectra-applications, and also
#  using that file for the analyses that are being done in report/
# using-sizeSpectra2.R - size spectrum fits using sizeSpectra2 functions.
#  Run from the same directory as 2023-03-22_Dades_RESNEP.xlsx, or setwd to the
#  required directory.
# Starting from analysis-juliana-2024-12-05.R
# which Andy tweaked (just commented out setwd in the end I think) to get
#  SizeSpectra_TaxonomicGroups_AE - x_min_12mm
# working on his machine. Juliana had sent that on 2024-12-05.

# Size spectra - Andy's code
# Only size spectra Analyses - without GADICULUS ARGENTEUS
# Palam√≥s 2017, 2021
# Juliana Quevedo Zabala
# 08 Oct 2023

#setwd("~/Desktop/ICM-CSIC/New size spectra - Andy")
# setwd("C:/Users/jqz96/OneDrive/Desktop/PhD/Publications/Quevedo et al. SIZE SPECTRA/Data")
```

# Data preparation

Juliana's code to load in and define the data. Not showing code or output
here.

```{r, datapreparation, echo = FALSE, warning = FALSE}
# DATA PREPARATION #############################################################
# DATA PREPARATION: FrequenciaDeTalles tab
resnep_raw <- readxl::read_excel("2023-03-22_Dades_RESNEP.xlsx",3)

resnep <- resnep_raw

resnep$Any <- as.character(resnep$Any)

# no cover data
resnep <- subset(resnep, CodiPesca != "20170823_64500_ESP000023428_03")

# exclude vessel: MEDAN in resnep due to different fishing technique which leads to bias in analysis
resnep <- subset(resnep, NomBarca != "MEDAN")

# exclude species whose length-weight relationship overestimate their weight by more then 200%
resnep <- subset(resnep, NomEspecie != "Sepietta spp." &
                   NomEspecie != "Sepietta oweniana" &
                   NomEspecie != "Histoteutis bonelli" &
                   NomEspecie != "Eledone cirrhosa" &
                   NomEspecie != "Macropipus tuberculatus" &
                   NomEspecie != "Squilla mantis" &
                   NomEspecie != "Scaeurgus unicirrhus" &
                   NomEspecie != "Gadiculus argenteus") # Gadiculus because it can be pelagic and amounts to a lot of variability in 2021
delete_CodiPesca <- "20170824_64500_ESP000023428_04"
delete_Name <- "Liocarcinus depurator"
# Delete rows matching the specified ID and Name
resnep <- resnep %>%
  filter(!(CodiPesca == delete_CodiPesca & NomEspecie == delete_Name))

# exclude from resnep21_fg trawls done beside the NTR -- too close
resnep <- subset(resnep, CodiPesca != "20210826_64500_ESP000023428_09" &
                   CodiPesca != "20210824_64500_ESP000023428_01" &
                   CodiPesca != "20210831_64500_ESP000023428_16")

resnep_for_length_weight_coefficients <- resnep    # To then extract what we
                                        # need below

# Make df smaller
resnep <- select(resnep, CodiPesca, NomPort, Data, Any, NumeroPesca, TipusDeFons, ProfunditatMitjana_m,
                 NomEspecie, ClassificacioCaptura, AgrupamentTaxonomic, Categoria, Talla_mm,
                 FrequenciaCalculada, Abundancia_NIndividusTalla_Km2, PesTotalCalculatRelacioTallaPes_g,
                 Biomassa_KgTalla_Km2, AreaEscombrada_km2, TipusMalla, Site)

# Spread datasets: FrequenciaCalculada - extrapolate subsamples and compute individual weights
resnep <- mutate(resnep, PesoIndividual = PesTotalCalculatRelacioTallaPes_g/FrequenciaCalculada)
resnep <- as.data.frame(lapply(resnep, rep, resnep$FrequenciaCalculada))
resnep['frecuencia_final'] = 1 # new column, frecuencias finales = 1

# Exclude sizes smaller than 12mm, as the net size was 12x12mm, we assume organisms <12mm are not well sampled
resnep <- subset(resnep, Talla_mm > 12)

# Andy doing this to create factors, to ask Juliana about some of the columns.
resnep_temp <- tibble::as_tibble(resnep) %>%
  dplyr::mutate_at(vars(CodiPesca,
                        NomPort,
                        Data,
                        Any,
                        TipusDeFons,
                        NomEspecie,
                        ClassificacioCaptura,
                        AgrupamentTaxonomic,
                        Categoria,
                        TipusMalla, # not sure, says logical but also NA's
                        Site),
                   factor)

summary(dplyr::select(resnep_temp,
                      NumeroPesca,
                      Talla_mm,
                      FrequenciaCalculada,
                      AgrupamentTaxonomic,
                      Abundancia_NIndividusTalla_Km2,
                      PesTotalCalculatRelacioTallaPes_g,
                      Biomassa_KgTalla_Km2,
                      AreaEscombrada_km2,
                      PesoIndividual,
                      frecuencia_final))


# separate resnep 2017 and 2021 (NTR & FG),
resnep17 <- subset(resnep, Any != "2021")
resnep21 <- subset(resnep, Any != "2017")
resnep21_ntr <- subset(resnep21, Site == "MPA")
resnep21_fg <- subset(resnep21, Site == "FG")


# FREQUENCY BARPLOTS, ABUNDANCIA VS TALLA PLOTS, ABUNDANCIA VS PESO PLOTS, METADATA ANALYSES,
# Weight and size supperposed histograms - see relationship, DENSITY HISTOGRAMS BY 'AGRUPAMENT TAXONOMIC':
# find in "SizeSpectra_Analyses_v5.R" ***


# SELECT DATASETS BY 'AGRUPAMENT TAXONOMIC'
# "Crustacea"  "Cephalopoda"  "Actinopterygii"  "Chondrichthyes"  "Echinodermata"
# Exclude Echinidermata due to very low organisms. max 10.

# resnep17
resnep17_crustacea <- subset(resnep17, AgrupamentTaxonomic == "Crustacea")
resnep17_cephalopoda <- subset(resnep17, AgrupamentTaxonomic == "Cephalopoda")
resnep17_actinopterygii <- subset(resnep17, AgrupamentTaxonomic == "Actinopterygii")
resnep17_chondrichthyes <- subset(resnep17, AgrupamentTaxonomic == "Chondrichthyes")

# TODO make these >=10 and elsewhere; check if makes a difference.
resnep17_cephalopoda_small <- subset(resnep17_cephalopoda, PesoIndividual < 10)
resnep17_cephalopoda_big <- subset(resnep17_cephalopoda, PesoIndividual > 10)

# resnep21_fg
resnep21_fg_crustacea <- subset(resnep21_fg, AgrupamentTaxonomic == "Crustacea")
resnep21_fg_cephalopoda <- subset(resnep21_fg, AgrupamentTaxonomic == "Cephalopoda")
resnep21_fg_actinopterygii <- subset(resnep21_fg, AgrupamentTaxonomic == "Actinopterygii")
resnep21_fg_chondrichthyes <- subset(resnep21_fg, AgrupamentTaxonomic == "Chondrichthyes")

resnep21_fg_cephalopoda_small <- subset(resnep21_fg_cephalopoda, PesoIndividual < 10)
resnep21_fg_cephalopoda_big <- subset(resnep21_fg_cephalopoda, PesoIndividual > 10)

# resnep21_ntr
resnep21_ntr_crustacea <- subset(resnep21_ntr, AgrupamentTaxonomic == "Crustacea")
resnep21_ntr_cephalopoda <- subset(resnep21_ntr, AgrupamentTaxonomic == "Cephalopoda")
resnep21_ntr_actinopterygii <- subset(resnep21_ntr, AgrupamentTaxonomic == "Actinopterygii")
resnep21_ntr_chondrichthyes <- subset(resnep21_ntr, AgrupamentTaxonomic == "Chondrichthyes")

resnep21_ntr_cephalopoda_small <- subset(resnep21_ntr_cephalopoda, PesoIndividual < 10)
resnep21_ntr_cephalopoda_big <- subset(resnep21_ntr_cephalopoda, PesoIndividual > 10)
```

Now just extracting and then saving the `PesoIndividual` column for each species
group and data set ("baseline", "fg", or "ntr"), as, for example,
`x_community_ntr`. Using the first syllable or so for the longer complex species
group names.

Baseline corresponds to 2017, but don't need to have the
date in the variable name. Doing the analyses in
`report/`, here just saving the data into the package. Each is then just a
vector of individual body masses. Andy adding in `as.numeric()` as just using
`na.omit()` keeps information (as attributes) about the indices (I presume) of
the omitted NA's, which we do not need.

```{r extractjustmasses}
x_community_baseline <- na.omit(resnep17$PesoIndividual) %>% as.numeric()
x_community_fg <- na.omit(resnep21_fg$PesoIndividual) %>% as.numeric()
x_community_ntr <- na.omit(resnep21_ntr$PesoIndividual) %>% as.numeric()


# Chondrichthyes
resnep17_chondrichthyes <- subset(resnep17_chondrichthyes, Talla_mm >100)
x_chondr_baseline <- na.omit(resnep17_chondrichthyes$PesoIndividual) %>% as.numeric()

x_chondr_fg <- na.omit(resnep21_fg_chondrichthyes$PesoIndividual) %>% as.numeric()
# TODO not
                                        # sure why not >100
x_chondr_ntr <- na.omit(resnep21_ntr_chondrichthyes$PesoIndividual) %>% as.numeric()
  # TODO not sure why not >100

# Cephalopoda -- All
x_ceph_all_baseline <- na.omit(resnep17_cephalopoda$PesoIndividual) %>% as.numeric()
x_ceph_all_fg <- na.omit(resnep21_fg_cephalopoda$PesoIndividual) %>% as.numeric()
x_ceph_all_ntr <- na.omit(resnep21_ntr_cephalopoda$PesoIndividual) %>% as.numeric()
```

Carrying on...


```{r continue}
# Cephalopoda -- Large
x_ceph_large_baseline <- na.omit(resnep17_cephalopoda_big$PesoIndividual) %>% as.numeric()
x_ceph_large_fg <- na.omit(resnep21_fg_cephalopoda_big$PesoIndividual) %>% as.numeric()
x_ceph_large_ntr <- na.omit(resnep21_ntr_cephalopoda_big$PesoIndividual) %>% as.numeric()

# Cephalopoda -- Small
x_ceph_small_baseline <- na.omit(resnep17_cephalopoda_small$PesoIndividual) %>% as.numeric()
x_ceph_small_fg <- na.omit(resnep21_fg_cephalopoda_small$PesoIndividual) %>% as.numeric()
x_ceph_small_ntr <- na.omit(resnep21_ntr_cephalopoda_small$PesoIndividual) %>% as.numeric()

# Actinopterygii
resnep17_actinopterygii <- subset(resnep17_actinopterygii, Talla_mm > 40)
x_actin_baseline <- na.omit(resnep17_actinopterygii$PesoIndividual) %>% as.numeric()

resnep21_fg_actinopterygii <- subset(resnep21_fg_actinopterygii, Talla_mm > 40)
x_actin_fg <- na.omit(resnep21_fg_actinopterygii$PesoIndividual) %>% as.numeric()

resnep21_ntr_actinopterygii <- subset(resnep21_ntr_actinopterygii, Talla_mm >40)
x_actin_ntr <- na.omit(resnep21_ntr_actinopterygii$PesoIndividual) %>% as.numeric()

# Crustacea
x_crust_baseline <- na.omit(resnep17_crustacea$PesoIndividual) %>% as.numeric()
x_crust_fg <- na.omit(resnep21_fg_crustacea$PesoIndividual) %>% as.numeric()
x_crust_ntr <- na.omit(resnep21_ntr_crustacea$PesoIndividual) %>% as.numeric()
```

Now save the values in the package. Maybe do as a single list. Then use list2env
in analysis.

TODO might not actually want this in the end.

```{r, savedata}
# This is alphabetical (from using ls()):
mediterranean_megafauna <- tibble::lst(x_actin_baseline,
                                       x_actin_fg,
                                       x_actin_ntr,
                                       x_ceph_all_baseline,
                                       x_ceph_all_fg,
                                       x_ceph_all_ntr,
                                       x_ceph_large_baseline,
                                       x_ceph_large_fg,
                                       x_ceph_large_ntr,
                                       x_ceph_small_baseline,
                                       x_ceph_small_fg,
                                       x_ceph_small_ntr,
                                       x_chondr_baseline,
                                       x_chondr_fg,
                                       x_chondr_ntr,
                                       x_community_baseline,
                                       x_community_fg,
                                       x_community_ntr,
                                       x_crust_baseline,
                                       x_crust_fg,
                                       x_crust_ntr)

usethis::use_data(mediterranean_megafauna,
                  overwrite = TRUE)
```

# For MLEbins method, need tibble of species-specific length-weight coefficients

Juliana already did the length-to-weight calculations in the spreadsheet. But we
need to explicitly do them as want the min and max possible weight for each
length bin.

So, using a version of the data that is saved above:

```{r, lwcoeffs}
length_weight_coefficients <- resnep_for_length_weight_coefficients %>%
  dplyr::select(species = NomEspecie,
                alpha = ConstantA_TallaPes,
                beta = ConstantB_TallaPes) %>%
  dplyr::mutate_at(vars(species),
                   factor)

length_weight_coefficients <-
  dplyr::summarise(dplyr::group_by(length_weight_coefficients,
                                   species),
                   alpha = unique(alpha),
                   beta = unique(beta))

length_weight_coefficients
summary(length_weight_coefficients)

mediterranean_length_weight_coefficients <-
  dplyr::filter(length_weight_coefficients,
                !is.na(alpha))

summary(mediterranean_length_weight_coefficients)

usethis::use_data(mediterranean_length_weight_coefficients,
                  overwrite = TRUE)
# TODO document, alpha and beta are the coeffcicients; need to describe units.
# This should be the standard way of using length-weight coefficients.
```

Thought about leaving the NA's in there for now, as a check with Juliana's that
none make it through to the analyses. But remove and just check that she has
none of the NA species TODO.



# For MLEbins method, need the following, looking at Table 1 in MEPS:

species, strata, length bin min, standardised count -- from data

then calculate:
weight bin min, weight bin max, biomass in that bin based on standardised count
(not actually need for likelihood, can leave the calc to plotting functions if
it's needed).

Take the full data set and then save what we need.
```{r, wrangling}
# Exclude sizes smaller than 12mm, as the net size was 12x12mm, we assume organisms <12mm are not well sampled

data_full <- dplyr::filter(resnep_for_length_weight_coefficients,
                           Talla_mm > 12,
                           !(AgrupamentTaxonomic %in% c("Echinodermata",
                                                        "Tunicata")))
                                # Exclude only 21
                                # and 24 rows for each
summary(as.factor(data_full$Site))   # Just need these as strata, TBA is baseline for
                                # the 4051 in 2017:
nrow(dplyr::filter(data_full, Site == "TBA" & Any == 2017))


expect_equal(data_full$Abundancia_NIndividusTalla_Km2,
             data_full$FrequenciaCalculada / data_full$AreaEscombrada_km2,
             tolerance = 0.0001)
# So I can just use Abundancia_NIndividusTalla_Km2, though would need
# FrequenciaCalculada for MLE method

data <- dplyr::select(data_full,
                      Site,
                      AgrupamentTaxonomic,
                      NomEspecie,
                      Talla_mm,
                      Abundancia_NIndividusTalla_Km2) %>%
  dplyr::mutate_at(vars(Site,
                        AgrupamentTaxonomic,
                        NomEspecie),
                   factor) %>%
  dplyr::rename(strata = Site,
                group = AgrupamentTaxonomic,
                species = NomEspecie,
                length = Talla_mm,
                number = Abundancia_NIndividusTalla_Km2)
# Rename in last bit to give standard general names (was thinking maybe applicable to other data
# sets, but here we still want to think of group as a strata, so maybe don't aim
# to get too clever and have a function to do everything, let people create a loop). TODO need to document what these mean in the help for the data object.

data

mediterranean_data <- data

summary(mediterranean_data)

usethis::use_data(mediterranean_data,
                  overwrite = TRUE)
```

```{r, notes}
# Notes from Juliana's email:

# Frequenciecaculada: 3 means measured 1/3 of the
# catch, or, equivalently (I think)
# there were 3 fish but only 1 was
# measured. So Juliana then creates 3
# individual identical rows in such a
# situation. 1 means no subsampling.

# Each tow covers a different area, we tried to make it so that eachtow last 1
# hour, but there were variations, so we use the trawled area km2 to standardize
# biomass and abundance data.


# 'PesTotalCalculatRelacioTallaPes_g' is the total weight of that species taking
# into account the subsample, meaning that if the total weight is 100g and the
# subsample is 5, 5 organisms of that species weight 100g, so each organism here
# weights 20g. - we won't need that as using length-weight relationships.

# NumeroPesca is Haul Number - not needed

# FrequenciaCalculada - The number of fish of a given length, species and haul is represented in FrequenciaCalculada. That's why I did the calculations on the first question, so that there would be one row for each individual, so using PesoIndividual accounts for everything.


# Abundancia_NIndividusTalla_Km2 this looks to be freq scaled by area of
# trawl, as verified in expect_equal above. If you just do MLE you can't
# take this into account though.

```



Combine rows that have the same strata, species, and length.
NO, had forgot about species groups when first doing this. So need to link this into a function for fitting (but do
each strata-group combination separately), having
done the data wrangling.
```{r, combinerows}
# Can see that have two 140s in same strata of same species:
#   dplyr::filter(mediterranean_data[1:100, ], species == "Lepidorhombus boscii", length == 140)
# so worth combining at this
# point. Might be harder to compare results to Juliana's (maybe not?), so can
# always comment this out, though MLEbins figures will be strange -- actually
# wrong as won't be able to see overlapping bins that are the same. So
# definitely need to do this. TODO include automatically in a function somehwere.
# Also mention that this sorts them alphabetically by strata, species, and then
# length.

# So deferring this to analysis by strata-group
#dat <- dplyr::summarise(group_by(mediterranean_data[1:1000, ],
#                                 # Just doing first 100  TODO
#                                 strata,
#                                 species,
#                                 length),
#                        bin_count = sum(number)) %>%
#  dplyr::ungroup()
#dat
```

Now combine length-weight coefficients and data. Then functionalise it once
worked out.

First, some lengths in original spreadsheet are to 0.01 mm and some to 1mm. Check
what we get after the refinements here. Given to mm scale, maybe MLEbins is
overkill. But I think the scaling by trawl area will result in non-integer
counts. And given the mixture does seem worth doing.

Can presume that a length to 2 decimal places is measured at resolution of 0.01,
whereas ones that are to integers were measured at resolution of 1 (except for
the 1 in 100 that come out as .00). Though when printed as tibble it keeps the
original format.

Juliana: The lengths with 0.01mm accuracy are all measured crustaceans, as
they're typically small and its the standard to measure them with a vernier
caliper. All other species were measured to the 1mm accuracy, as we used a
standard lab metric tape. So if we have 27 its correct to say it is 27.00. With
this in mind, I would define b) 26.5 - 27.5 mm as the bin value for 27.00.

And for the 0.01 mm accuracy it really isn't going to make much difference
exactly how
we define the bin, so say 26.13 is 26.125-26.135 for consistency. (Have to
assume this for `calc_max_of_bin()`.



```{r, calcbins}
dat_bin_breaks <- calc_max_of_bin(dat$length,
                                  bin_widths = c(0.01, 1))

# These are lengths, might want to note that, TODO prob want one big function to
# generalise, with an input being whether data are lengths or weights, to then
# automatically pick methods. Might get a bit fiddly.

dat <- cbind(dat,
             dat_bin_breaks) %>% tibble::as_tibble() %>%
       dplyr::rename(length_bin_min = bin_min,
                     length_bin_max = bin_max)

dat_joined <- dplyr::left_join(dat,
                               mediterranean_length_weight_coefficients,
                               by = "species") %>%
  dplyr::mutate(weight_bin_min = alpha * (length_bin_min/10)^beta,
                weight_bin_max = alpha * (length_bin_max/10)^beta) %>%
  dplyr::filter(!is.na(alpha))  # remove species with no length-weight
                                # coefficients

                # biomass_bin_min = bin_count * weight_bin_min,  # TODO get rid of
                                        # these I think.
                # biomass_bin_max = bin_count * weight_bin_max) %>%



# TODO numbers look funny, expect need to be more careful with units. GUESSING
# that alpha and beta refer to cm, hence the /10 above. Then I think body
# weights are in grammes - have asked Juliana. But then she gives
# Biomassa_KgTalla_Km2 which is kg, so I need to scale to match that. But I
# don't think I need biomass in a bin (see next), so just keep for now to check
# calculations.

# TODO don't think biomass in bin is actually needed as input for likelihood
# function. Might be needed for plotting.
dat_joined[1, ] %>% a()

# Check a value:

example <- dplyr::filter(resnep_raw,
                         NomEspecie == "Abralia veranyi",
                         Talla_mm == 28,
                         Site == "TBA") %>%
  dplyr::select(NomEspecie,
                Talla_mm,
                Abundancia_NIndividusTalla_Km2,
                ConstantA_TallaPes,
                ConstantB_TallaPes,
                Biomassa_KgTalla_Km2)
example %>% a()

# These should match:
#dplyr::select(example,
#              Abundancia_NIndividusTalla_Km2,
#              Talla_mm,
#              Biomassa_KgTalla_Km2)[1,]

#dplyr::select(example,
#              Abundancia_NIndividusTalla_Km2,
#              Talla_mm,
#             Biomassa_KgTalla_Km2)[1,"Biomassa_KgTalla_Km2"] %>% a()

#dat_joined[1, c("length", "bin_count", "biomass_bin_min")]
# Looks like ours is still grammes, as expected, so convert to kg:
#dat_joined[1, "biomass_bin_min"]/1000

# Slightly off, likely just rounding, just check:
#dplyr::select(example,
#              Abundancia_NIndividusTalla_Km2,
#              Talla_mm,
#              Biomassa_KgTalla_Km2)[1,"Biomassa_KgTalla_Km2"] - 0.09
# Don't worry though.
```
Okay, so lengths in mm are converted to cm for the length-weight calculations,
and then for total biomass converted to kg, though we won't actually need that directly.

This would seem to have the data in the format required for analysis. We would
actually functionalise some of the above steps, and just require the raw data
and l-w coefficients.

HERE HERE HERE - redo this when done later HERE's (maybe done?)

Just want to analyse one strata at a time. Do baseline here then functionalise
to make a loop. TODO. Or maybe do each in turn to keep track for this example.

For a given data set to be fit, do a
function to combine numbers for which we have the same species and length
bin. Can actually do that early on.

```{r, analyse}
dat_baseline <- dplyr::filter(dat_joined,
                              strata == "TBA")

dat_for_mlebins <- dplyr::select(dat_baseline,
                                 species,
                                 bin_count,
                                 bin_min = weight_bin_min,
                                 bin_max = weight_bin_max)

res_mlebins <- fit_size_spectrum(dat_for_mlebins)

> res_mlebins <- fit_size_spectrum_mlebins(dat_for_mlebins)  # should work

res_mlebins
```

```{r plotmlebins}
plot(res_mlebins)   # worked, but hadn't done the groups yet.
```

## Functionalising those last calculations

MOVING to zabala-data-analysis.Rmd to keep separate from the data wrangling, as
data is saved in the package.









# Check code using dataOrig from sizeSpectra, which is Fung data.

Need to accomodate the 0.5 cm bins though. Just do one year for now. Then write
functions to reproduce resutls for all years, and automatically do all stratea
for Med data.

Note that LngtClas is in mm, not cm, but that a and b are the length-weight
coefficients for the length being in cm. For sizeSpectra vignette used cm as
units later in that code.

First attempt here was using `dataOrig`, but I'd already tidied it up in
`IBTS_data` so second attempt is trying that.

Figured out the bug in this, see the TODO towards the end, but for now carrying
on with chunk after this, as this still has some data-specific wrangling in it.

```{r fungdata, eval = FALSE, echo = FALSE}
fung_1999 <- sizeSpectra::dataOrig %>%
  dplyr::filter(Year == 1999)

fung_use <- dplyr::select(fung_1999,
                          species = Species,
                          length = LngtClas,
                          alpha = a,
                          beta = b,
                          bin_count = CPUE_number_per_hour)

fung_use_simplify <- dplyr::summarise(group_by(fung_use,
                                               species,
                                               length),
                                      alpha = unique(alpha),
                                      beta = unique(beta),
                                      bin_count = sum(bin_count)/7) %>%
  dplyr::ungroup()
# Divide by 7 is because there were 7 areas, so it's really a mean. Did that in
# the MEPS_IBTS_1.html vignette.
# TODO check that I did something like this in MEPS vignette, summing duplicate
# combinations.

# Lengths are in mm here
fung_use_simplify

fung_bin_breaks <- calc_max_of_bin(fung_use_simplify$length,
                                   bin_widths = 10)    # 10 mm

herring_and_sprat_indices <- which(fung_use_simplify$species %in%
                                   c("Clupea harengus", "Sprattus sprattus"))

herring_and_sprat_indices

fung_bin_breaks[herring_and_sprat_indices, "bin_max"] =
  fung_bin_breaks[herring_and_sprat_indices, "bin_max"] - 5

# Again, /10 as lengths are in mm but lenght-weight coefficients are cm
fung_dat <- cbind(fung_use_simplify,
                  fung_bin_breaks) %>%
  tibble::as_tibble() %>%
  dplyr::rename(length_bin_min = bin_min,
                length_bin_max = bin_max) %>%
  dplyr::mutate(weight_bin_min = alpha * (length_bin_min/10)^beta,
                weight_bin_max = alpha * (length_bin_max/10)^beta,
                biomass_bin_min = bin_count * weight_bin_min,
                biomass_bin_max = bin_count * weight_bin_max) %>%
  dplyr::filter(!is.na(alpha),  # remove species with no length-weight coefficients
                bin_count != 0,
                weight_bin_min >= 4) %>%    # 4g and above.
  dplyr::arrange(weight_bin_min)      # Makes sense to order in terms of bins,
                                      # as don't care about species now. Then
                                      # makes figure plot in the order as in MEPS.

fung_dat[1:10, ] %>% a()

sum(fung_dat$bin_count)   # This should equal n = 7199.6 for 1999I think, from MEPS
# Figure 7. DOES.

fung_dat_for_mlebins <- dplyr::select(fung_dat,
                                      species,
                                      bin_count,
                                      bin_min = weight_bin_min,
                                      bin_max = weight_bin_max)

fung_dat_for_mlebins

stopifnot(min(diff(fung_dat_for_mlebins$bin_min)) <= 0)  # check it's ascedning

res_fung_mlebins_1999 <- fit_size_spectrum(fung_dat_for_mlebins)

res_fung_mlebins_1999

# plot.size_spectrum_mlebin(res_fung_mlebins_1999)  # TODO so think we can just
# say

# Now have just:
plot(res_fung_mlebins_1999)
```

Woo-hoo, matches Table S.2 and Figure 7.

For figure to work as for MEPS, need to sort by `weight_bin_min` somewhere
above. Makes sense to do at once the weight bins have been calculated. Doing
that in plotting code.

HERE HERE HERE: -
  D check plot,
  D commit,
then work out which version to keep (which is more
generalisable), this one or the next. Then simplify this down, and apply to Med data. Actually make
a new vignette showing it reproduces results from MEPS. Should then
functionalise approach with a strata option.


TODO decide which to keep, this or the above one:
Trying with `IBTS_data`:

```{r, fungibtsdata}

fung_1986 <- sizeSpectra::IBTS_data %>%
  dplyr::filter(Year == 1986)

fung_use <- dplyr::select(fung_1986,
                          species = SpecCode,
                          length = LngtClass,
                          alpha = LWa,
                          beta = LWb,
                          bin_count = Number)

# This checking of dulpication was already done, but keep here as want to
# include in a function:
fung_use_simplify <- dplyr::summarise(group_by(fung_use,
                                               species,
                                               length),
                                      alpha = unique(alpha),
                                      beta = unique(beta),
                                      bin_count = sum(bin_count)) %>%
  dplyr::ungroup()



attributes(fung_use) <- attributes(fung_use_simplify) # so expect equal works

expect_equal(fung_use,
             fung_use_simplify)


# NOT NEEDED NOW: Divide by 7 is because there were 7 areas, so it's really a mean. Did that in
# the MEPS_IBTS_1.html vignette.
# TODO check that I did something like this in MEPS vignette, summing duplicate
# combinations.

# Lengths are in cm
fung_use_simplify

fung_bin_breaks <- calc_max_of_bin(fung_use_simplify$length,
                                   bin_widths = 1)    # 10 mm

# Indices corresponding to herring and sprat (bin breaks of 0.5 cm); could let people add this in in an
# extra step, doesn't really need including in calc_max_of_bin. Okay to do here
# as order not changing for next tibble.
herring_and_sprat_indices <- which(fung_use_simplify$species %in% c(126417, 126425))

herring_and_sprat_indices

fung_bin_breaks[herring_and_sprat_indices, "bin_max"] =
  fung_bin_breaks[herring_and_sprat_indices, "bin_max"] - 0.5

# TODO ignoring Atlantic Herring and European Sprat which are 0.5
#  So expect results to be slightly different until do that. But total sum of
#  counts should be the same, the bins will just be defined slightly wrong.

# Lengths are in cm as for length-weight coefficients are cm, probably a good
# rule of thumb to do
fung_dat <- cbind(fung_use_simplify,
                  fung_bin_breaks) %>%
  tibble::as_tibble() %>%
  dplyr::rename(length_bin_min = bin_min,
                length_bin_max = bin_max) %>%
  dplyr::mutate(weight_bin_min = alpha * length_bin_min^beta,
                weight_bin_max = alpha * length_bin_max^beta,
                biomass_bin_min = bin_count * weight_bin_min,
                biomass_bin_max = bin_count * weight_bin_max) %>%
  dplyr::filter(!is.na(alpha),  # remove species with no length-weight coefficients
                bin_count != 0,
                weight_bin_min >= 4)    # 4g and above.

fung_dat[1:10, ] %>% a()

sum(fung_dat$bin_count)   # This should equal n = 7199.6 for 1999I think, from MEPS
# Figure 7. BUT check what data I'm using, switching to 1986 as results are
# shown in vignettes. 1986 should be 4799.29, at least after the
# calculations. Matches. 1999 should now also, as should above calcs.


# [30/4/2025 Started new R session, old one is still open in another buffer]
```



 TODO put a remove bin count or number of 0 in somewhere early when
 functionalising especially.

Now to do the calculations:
```{r fungcalcs}
fung_dat_for_mlebins <- dplyr::select(fung_dat,
                                      species,
                                      bin_count,
                                      bin_min = weight_bin_min,
                                      bin_max = weight_bin_max)

fung_dat_for_mlebins

res_fung_mlebins <- fit_size_spectrum(fung_dat_for_mlebins)

res_fung_mlebins
```

Woo-hoo, that matches Table S.2 of MEPS paper.



TODO HERE may ahve to go back and think about units again. Set up some rules,
maybe convert to cm straight away. Think that's best.
